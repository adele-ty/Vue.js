## Vue2实现响应式数据的过程：
当Vue.js创建一个数据对象时，它会对这个对象进行“响应式化”，即将对象中的每个属性都转换为getter/setter方法。这个过程叫做“数据劫持”，它的实现主要依赖于Object.defineProperty()这个API。具体来说，实现的过程如下：  
* 遍历数据对象的所有属性。  
* 对于每个属性，使用Object.defineProperty方法将其转换为getter/setter方法，从而实现属性的“劫持”。例如，假设有一个数据对象data，其中有一个属性name，那么Vue.js会将它转换为：
```
Object.defineProperty(data, 'name', {
  get() {
    // 收集依赖
    return name
  },
  set(newValue) {
    // 更新视图
    name = newValue
    // 触发依赖更新
  }
})
```  
* 在setter方法中，会触发“依赖更新”，即通知依赖这个属性的组件或视图进行更新。Vue.js内部维护了一个“依赖收集器”，它会自动记录所有组件或视图的依赖关系，并且在响应式属性变化时，通知所有相关的依赖进行更新。  
* 在getter方法中，Vue.js会执行“依赖收集”，即记录当前组件或视图依赖的所有响应式属性。这个过程是通过使用JavaScript的闭包实现的，即在getter方法中引用一个变量Dep，然后在Dep中记录当前的依赖关系。  
* 当一个组件或视图渲染时，它会执行render函数，并引用所有需要的响应式属性，当访问属性的getter方法时，属性会自动与组件或者视图建立依赖关系。而当某个响应式属性发生变化，会自动调用该属性的setter方法，并且通知所有依赖这个属性的组件或者视图进行更新。  
## Vue3实现响应式数据的过程：
Vue3对响应式数据的实现方式做出了重大改进，主要依赖于ES6中的Proxy对象，相对于Vue2的实现方式，Proxy的性能更高，代码量也更少。具体实现过程如下：  
* 在组件初始化时，使用reactive()函数将数据对象转换为响应式对象。  
* 在reactive()函数中，使用Proxy对象代理数据对象，拦截属性的 getter 和 setter 函数。  
* 依赖该数据 / 属性的方法（副作用 effect）默认会先执行一次，触发所依赖属性的 get 方法，在 getter 函数中进行依赖收集（track，把当前属性与当前的 effect 建立联系，即映射表）。  
* 当属性变化时，会触发其 set 方法，在 setter 函数中进行更新（trigger，依次触发映射表中依赖当前属性的 effect）。  
